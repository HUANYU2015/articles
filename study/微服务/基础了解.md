# 微服务

## 架构设计

### 技术上的改进

* 前后端分离，**web 前端通过 HTTP、HTTPS 协议调用微服务的 API 网关**，由API网关在经过路由服务调用相应的微服务。
* 不同微服务之间通过 rest 方式互相调用
* **微服务之间通过消息中间件实现消息交互机制**

### 配套服务和功能实现

* 需要相应的自动化服务实现，包括自动化构建、自动化安装部署、自动化测试以及自动化平台发布（Docker 实现）
* 管理服务，对于微服务架构，必须配套相应的监控和管理服务、日志管理服务等
* 协作服务，运用 Devops 思想提升开发、测试、运维的高效沟通与协作，实现开发与运维一体化。

### 微服务建构设计

* 将整个系统根据业务拆分成若干个子系统或微服务
* 每个系统可以部署多个应用，多个应用之间考虑负载均衡
* 需要一个服务注册中心 Eureka，所有服务都需在注册中心注册，负载均衡也是通过在注册中心注册的服务来使用一定的策略来实现的，Eureka 可部署多个，进行高可用保证
* **所有的客户端都通过一个网关地址访问后台的服务，通过路由配置 ZUUL网关来判断一个 URL 请求由哪个服务器处理**。请求转发到服务商的时候使用负载均衡 Ribbon
* 服务之间采用 feign 进行调用（REST形式）
* 使用断路器 hystrix，及时处理服务器调用时的超时和错误，防止由于其中一个服务的问题导致整个系统的瘫痪，只需要在服务接口上添加 Hystrix 标签，就可以实现对这个接口的监控和断路器功能
* Hystrix Dashboard，监控面板，可以监控各个服务调用所消耗的时间等信息
* 添加监控功能，监控每个服务器调用所花费的时间
* 使用 springcloud config 进行统一的配置管理
* Turbine，监控聚合。使用 Hystrix 对服务进行监控时，一般需要打开每一个服务实例的进行监控信息的查看，而使用 Turbine 可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看。

### 架构可靠性保证

* AccessControl: Zuul 网关提供相关控制功能。
* Config Server: Spring Cloud 提供远程配置中心。

## 设计阶段

### 总体设计

* 功能规划
  * 对产品进行拆分，拆分为若干个微服务，一个功能可以创建多个微服务，并部署在多个服务器节点上，便于进行负载均衡
* 设计原子服务层
  * 梳理和抽离核心应用、公共应用，作为独立服务下沉到核心和公共能力层，逐渐形成稳定的服务中心
* 为每个服务设计 API 接口 （REST方式）
* 将服务进行分类，不同类型的服务需要的资源不同，可配置不同的资源

### 服务拆分原则

* 粒度微小
  * 根据业务功能划分服务粒度，总的原则是服务内部内聚，服务之间低耦合
* 责任单一
  * 每个服务只做一件事，即单一职责原则
* 隔离性原则
  * 每个服务相互隔离，互不影响
* 业务无关优先原则
  * 基础业务，一些基础组件，与具体的业务无关。比如短信服务、邮件服务。这些服务最容易划分出来做微服务，也是第一优先分离出来的服务

### 服务规划

为实现负载均衡，**允许相同的服务在多个节点注册相同的服务名，不同的端口**。如果没有前期的规划，不同的服务提供者可能会注册相同的服务名，导致消费者调用服务时产生调用混乱。

因此，需进行服务名的统一规划：

* 规划期统一制定每个服务提供者的服务名或者模块标示。
* 服务名的命名规则:ModuleName_ServiceName，且所有字符小写，不同单词之间以下划线分隔。如用户管理模块提供了获取用户信息的服务，则命名为：user_get_info。
* 新增服务名时，需要提出申请，审批通过后方可使用，**为减少审批复杂度，可只审批ModuleName，即在模块内部可以自由增加服务名，不需要进行审批**。

### 开发策略

总体原则：不同的微服务需要进行物理隔离

* `SVN策略`：SVN上创建独立的分支，不同微服务的代码提交不受相互影响；
  * 由配置管理员统一控制。
  * 问题：开发分支与集成分支，都将增加很多，维护工作量增加。
* `编译策略`：代码编译时，各个微服务独立编译、打包，杜绝直接的依赖；
* `工程构建`：代码开发时，各微服务创建独立的工程，工程之间不能产生直接依赖
* `持续集成`：每个微服务独立执行持续集成。
* `版本集成`：由统一的集成工具，实现自动化的版本集成，将所有微服务集成到统一的版本发布包中。

### 版本策略

每个微服务可以独立制作版本，伴随着服务的增多，SVN分支增多，版本也将增多，版本管理的复杂度将会成指数级增长。在服务之间依赖比较多时，每个服务的升级或者降级多将会影响其他服务的正常运行。

因此需要执行特定的策略。

因此需执行如下策略：

* 所有服务的版本制作交由专业的版本管理员执行。
* 采用**自动化的版本制作策略**，最大程度的减少人工操作。
* 每个服务的版本必须有详细的版本计划、版本说明，对于版本说明要制定模板，明确需要提交的内容、版本号、SVN标签等。
* 对项目经理的要求提升，需对整体的版本计划有严格的制定，尤其是**版本之间的依赖关系要非常明确**，版本升级、降级的风险评估需完全充分。
* 接口管理：**严格执行接口管理制度**，任何接口的变更必须进行审批、发公告等流程。

### 数据库的挑战和策略

由于每个微服务都有自己独立的数据库，在需要进行联合查询时，需要做一些处理，具体方案有三种：

* 严格按照微服务的划分来做，微服务相互独立，各微服务数据库也独立，后台需要展示数据时，调用各微服务的接口来获取对应的数据，再将数据处理后展示出来，这是标准的用法，也是最麻烦的用法。
* 将业务高度相关的表放到一个库中，将业务关系不是很紧密的表严格按照微服务模式来拆分，这样既可以使用微服务，也避免了数据库分散导致后台系统统计功能难以实现，是一个折中的方案。
* 数据库严格按照微服务的要求来切分，以满足业务高并发，实时或者准实时将各微服务数据库数据同步到NoSQL数据库中，在同步的过程中进行数据清洗，用来满足后台业务系统的使用，推荐使用MongoDB、HBase等。

>> 第一种方案适合业务较为简单的小公司；第二种方案，适合在原有系统之上，慢慢演化为微服务架构的公司；第三种适合大型高并发的互联网公司。

### 负载均衡

不再采用一般的增加负载均衡服务器的方式进行负载均衡，如F5、Nginx、LVS等，而是把负载均衡的功能以库的方式集成到服务消费方的进程内，这种方案称为软负载均衡（Soft Load Balancing）或者客户端负载均衡。在Spring Cloud中配合Eureka的服务注册功能，Ribbon子项目则为REST客户端实现了负载均衡。

### 性能策略

### 技术管理策略

## 开发阶段

### 服务的调用

### 服务的熔断处理

### 统一日志管理

### 统一监控管理

### 统一配置管理

### 分布式 session

### rest 资源响应结构

### API 调用链追踪

### 单元测试

### 代码调试

## 测试

## 持续集成

## 运维阶段

